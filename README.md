# REDOX - global state management for PureScript apps

Redox - since it mixes well with [Thermite](https://github.com/paf31/purescript-thermite) ;)

This is `redux` type store, but instead of forcing you to write interpreter
as a reducer you are free (or rather cofree ;)) to write it the way you want.
The library will give you different schemes how the store is updated.  Now
there is only one `Redox.DSL`, but in near future there will be at least one
more using coroutines (similar to how
[Thermite](https://github.com/paf31/purescript-thermite) updates react
component state). 

# Redox.DSL

A DSL has to be interpreted in the `Aff` monad.  Since `Aff` has an instance of
`MonadEff` this does not restrict you in any way.  Checkout tests how to write
synchronous and asynchronous commands

In general if your `DSL` is generated by a functor `C` (for commands):
```purescript
type DSL = Free C
```
then you have to find a functor `RunC eff` which pairs with `C`:
```purescript
pair :: forall eff x y. C (x -> y) -> RunC eff x -> Aff eff y
```
You can deduce from `pair` type that if `C` is a sum type then `RunC` is
a product - that's how it interprets `C`.

Then the interpreter has type:
```purescript
type Interp eff a = Cofree (RunC eff)
```

This give rise to a function
```purescript
runInterp :: forall state. DSL(state -> state) -> RunC eff state -> Aff eff state
runInterp cmds state = exploreM pair cmds $ mkInterp state
```

You can feed this function into `Redox.DSL.dispatch`:
```purescript
dispatchS :: forall eff state. DSL(state -> state) -> Aff (redox :: Redox | eff) state
dispatchS = Redox.DSL.dispatch (\_ _ -> pure unit) runInterp store
```

Check out tests for an example or this
[repo](https://github.com/coot/purescript-dsl-example).  However you can write
an interpreter without `Cofree`, simply by using `State` to track the state, or
just by hand.  The advantage of using `Cofree` is that whenever you will change
`C` the compiler will force you to update `RunC` in compatible way.
